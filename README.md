> **本项目针对此文档实训题进行练习，如果难度跨越过大，可能会对文档和相应代码进行修改。**
>
> **温馨提示**：因本人水平有限，所以本项目代码只作为参考，大家可以用更好的办法实现，如果能百忙中抽空指点不胜感激。

通过以下系统的学习计划和详细的练习任务，Java 初学者可以逐步掌握 Java 编程的核心知识点。从基础的输入输出、操作符，到面向对象编程、集合使用，再到多线程和定时器应用，最后通过桌面应用和综合项目练习，全面提升编程能力。

---

### **初级阶段（基础知识）**

#### 1. **输入输出**

- **练习1：Hello World**
  - **描述**：编写一个 Java 程序，输出 `Hello World` 到控制台。
  - **难度**：极低，主要熟悉 Java 开发环境和基本语法。

- **练习2：Hello yourname**

  - **描述**：编写一个 Java 程序，要求用户在控制台输入他们的姓名，然后输出 `Hello [姓名]`，其中 `[姓名]` 为用户输入的姓名。
  - **难度**：极低，主要熟悉 Java 开发环境和基本语法。

#### 2. **变量、常量、数据类型、操作符**

- **练习：BMI 计算器**
  - **描述**：编写一个 Java 程序，要求用户输入体重（公斤）和身高（米），计算并输出他们的 BMI 指数。使用适当的数据类型存储值，并格式化输出结果到小数点后两位。

  - **公式**：BMI = 体重（kg）/（身高（m） * 身高（m））

- **难度**：低，中等，掌握不同数据类型的使用和变量的操作。

---

### **中级阶段（控制结构与面向对象）**

#### 1. **条件语句**

- **练习：闰年判断**

  - **描述**：编写一个 Java 程序，要求用户输入年份，判断该年份是否为闰年。判定规则：

    ```
    - 能被4整除但不能被100整除的是闰年
    - 能被400整除的是闰年
    ```

  - **输出示例**：“2024 年是闰年” 或 “2023 年不是闰年”

  - **难度**：低，理解 if-else 条件控制。

#### 2. **循环语句**

- **练习1：质数判定**

  - **描述**：编写一个 Java 程序，要求用户输入一个正整数，判断它是否为质数（素数）。如果是质数，输出“XX 是质数”；否则，输出“XX 不是质数”。

  - **难度**：中等，掌握 for、while 循环及逻辑判断。

- **练习2：九九乘法表**

  - **描述**：使用循环语句打印标准的九九乘法表，格式如下：

    ```
    1 x 1 = 1
    1 x 2 = 2   2 x 2 = 4
    1 x 3 = 3   2 x 3 = 6   3 x 3 = 9
    ...
    ```

  - **难度**：中等，掌握 for、while 循环及逻辑判断。

#### 3. **面向对象**

- **练习：银行账户管理系统**

  - **描述**：设计一个 `BankAccount` 类，包含以下属性和方法：

    - **属性**：
      - 账户持有人姓名（`String`）
      - 账户余额（`double`）

    - **方法**：
      - 存款 `deposit(double amount)`
      - 取款 `withdraw(double amount)`
      - 查询余额 `checkBalance()`

  - **要求**：编写测试代码，创建多个 `BankAccount` 对象，模拟存款、取款、查询余额等操作。

  - **难度**：中等，理解类、对象、方法及封装概念。

---

### **进阶阶段（数据结构与工具类）**

#### 1. **集合**

- **练习：学生成绩管理系统**

  - **描述**：编写一个 Java 程序，使用 `ArrayList` 或 `HashMap` 来管理学生的姓名和对应的成绩，实现以下功能：

    - 添加学生成绩
    - 删除学生成绩
    - 修改学生成绩
    - 查询所有学生的成绩列表
    - 查询指定学生的成绩

  - **要求**：提供一个菜单界面，供用户选择执行上述功能。

  - **难度**：中等，熟悉 `ArrayList` 或 `HashMap` 的使用及基本操作。
    >**提示**：可以不考虑代码重复问题，直接完成即可。
#### 2. **String**

- **练习：字符串密码强度检测**

  - **描述**：编写一个 Java 程序，要求用户输入一个密码字符串，检测该密码的强度。密码强度判定规则：

    - 包含数字、字母（大小写均可）、特殊字符三类中的两类，且长度不少于8位，判定为强密码。
    - 否则，判定为弱密码。

  - **要求**：输出检测结果，并建议用户如何提高密码强度。

  - **难度**：中等，掌握字符串操作和正则表达式基础。

#### 3. **Math**

- **练习：计算球的体积和表面积**

  - **描述**：让用户输入球的半径，结合 Math 类计算：

    - 球的体积：

      V = 4/3 * π * r^3

    - 球的表面积：

      A = 4 * π * r^2

  - **提示**：使用`Math.PI`代替Π进行计算，`Math.pow()`进行立方操作。

  - **难度**：低，运用`Math`类进行数学运算。

- **练习：猜数字游戏**

  - **描述**：编写一个 Java 程序，生成一个 1 到 100 之间的随机整数，要求用户猜测该数字。程序根据用户的输入给予提示“猜大了”或“猜小了”，直到用户猜中为止，并统计用户猜测的次数。

  - **提示**：使用 `Math.random()` 或 `Random` 类生成随机数。

  - **难度**：低，中等，运用 `Math` 类进行随机数生成。

#### 4. **Date**

- **练习：倒计时程序**

  - **描述**：编写一个 Java 程序，要求用户输入一个未来的日期，程序计算并输出从当前日期到目标日期之间还剩余的天数。
  - **要求**：处理日期格式的输入和解析，考虑日期输入的合法性。
  - **提示**：使用jdk8新日期库的`Period`类计算日期差值。
  - **难度**：中等，掌握日期和时间的处理。

---

### **高级阶段（I/O与并发编程）**

#### 1. 泛型

- **练习1：通用数据容器类**

  - **描述**

    - 设计并实现一个通用的数据容器类`DataContainer<T>`，能够存储和管理不同类型的数据。该容器应支持添加、删除、查找和遍历元素的功能，通过使用泛型确保类型安全和灵活性。

  - **要求**

    **1. 容器功能**：

    - **添加元素**：方法`void add(T item)`，将元素添加到容器中。
    - **删除元素**：方法`boolean remove(T item)`，根据元素内容删除指定元素。
    - **查找元素**：方法`boolean contains(T item)`，检查容器中是否存在指定元素。
    - **获取元素**：方法`T get(int index)`，根据索引获取元素。
    - **遍历元素**：提供一个方法`void forEach(Consumer<T> action)`，对每个元素执行指定的操作。

    **2. 内部实现**：

    - 使用数组或`ArrayList`作为底层数据结构，确保动态扩展能力。
    - 实现自动扩充容量的机制，当容器满时自动增加容量。

    **3. 泛型支持**：

    - 确保`DataContainer`能够存储任意类型的数据，如`DataContainer<String>`、`DataContainer<Integer>`等。
    - 保持类型安全，避免运行时类型转换错误。

    **4.示例应用**：

    - 创建一个`DataContainer<String>`实例，添加若干字符串，进行删除和查找操作，并遍历所有元素。
    - 创建一个`DataContainer<Integer>`实例，添加若干整数，执行相应操作。

  - **提示**

    - 利用Java的泛型特性，实现类的类型参数化。
    - 可以使用`ArrayList<T>`简化底层存储和动态扩展的实现。
    - 使用Java 8的`Consumer<T>`接口实现遍历操作。

  - **难度**：中等，适合初学者理解并应用泛型类和常用集合操作。

- **练习2：泛型工具类**

  - **描述**

    - 创建一个泛型工具类`Utils`，包含常用的泛型方法，如最大值查找、数组转换和元素交换等。通过这些方法，练习泛型方法的定义与应用。

  - **要求**

    - **1. 最大值查找**：

      - 方法签名：

      ```
      public static <T extends Comparable<T>> T findMax(T[] array)  
      ```

      - 功能：返回数组中的最大元素。

    - **2. 数组转换**：

      - 方法签名：

      ```
      public static <T, U> U[] convertArray(T[] array, Function<T, U> converter)  
      ```

      - 功能：将类型为`T`的数组转换为类型为`U`的数组，使用提供的转换函数。

    - **3. 元素交换**：

      - 方法签名：

      ```
      public static <T> void swapElements(T[] array, int i, int j)  
      ```

      - 功能：交换数组中索引为`i`和`j`的元素。

    **示例应用**：

    - **最大值查找**：使用`findMax`方法查找不同类型数组（如`Integer[]`、`String[]`）的最大元素。
    - **数组转换**：将`Integer[]`转换为`String[]`，每个整数转换为其字符串表示。
    - **元素交换**：交换不同类型数组中的元素，并验证交换结果。

  - **提示**

    - 利用泛型方法的定义，确保方法可以处理多种数据类型。
    - 使用`Function<T, U>`接口简化数组转换过程。
    - 在`findMax`方法中，确保元素类型实现了`Comparable`接口以支持比较操作。

  - **难度**：中等，适合初学者掌握泛型方法及其在实际问题中的应用。

#### 2. 反射

- **练习1：动态命令执行器**

  - **描述**

    构建一个简单的命令执行框架，通过反射机制根据命令名称动态加载并执行相应的命令类。此练习旨在帮助您理解如何利用反射动态创建对象和调用方法。

  - **要求**

    1. **命令接口**：
       - 创建一个接口`Command`，包含方法`void execute()`。
    2. **具体命令类**：
       - 实现多个具体命令类，如`SayHelloCommand`、`SayGoodbyeCommand`，每个类实现`Command`接口，并在`execute`方法中打印不同的信息。
    3. **命令执行器**：
       - 创建一个类`CommandExecutor`，包含方法`void executeCommand(String commandName)`。
       - 使用反射根据`commandName`动态加载对应的命令类，创建实例并调用其`execute`方法。
       - 命令类的命名约定为`<CommandName>Command`，如`SayHello`对应`SayHelloCommand`类。
    4. **示例应用**：
       - 在主程序中，通过用户输入或预设的命令名称，调用`CommandExecutor`执行相应的命令。
       - 测试不同命令的动态加载与执行。

  - **提示**

    - 使用`Class.forName()`根据类名加载类。
    - 使用`getDeclaredConstructor().newInstance()`创建类的实例。
    - 处理可能的异常，如`ClassNotFoundException`、`InstantiationException`等。

  - **难度**：中等，适合初学者理解反射的基本用法和其在动态加载类中的应用。

------

- **练习2：属性自动打印器**

  - **描述**

    实现一个工具类`ObjectPrinter`，通过反射自动打印任意对象的所有属性及其值。此练习帮助您掌握如何使用反射访问对象的字段，包括私有字段。

  - **要求**

    1. **打印方法**：

       - 创建一个类`ObjectPrinter`，包含方法`void printObject(Object obj)`。
       - 使用反射遍历`obj`的所有字段（包括私有字段），并打印每个字段的名称和值。

    2. **访问私有字段**：

       - 在访问私有字段时，使用`setAccessible(true)`以绕过访问限制。

    3. **格式化输出**：

       - 以清晰的格式输出属性名称和值，如：

         ```
         Class: Person  
         name: 张三  
         age: 25  
         address: 北京市  
         ```

    4. **示例应用**：

       - 创建多个不同的类实例，如`Person`、`Book`，并填充其字段。
       - 使用`ObjectPrinter`打印这些对象的属性和值，验证反射的访问效果。

  - **提示**

    - 使用`obj.getClass()`获取对象的`Class`对象。
    - 使用`getDeclaredFields()`获取所有字段，包括私有字段。
    - 处理可能的异常，如`IllegalAccessException`。

  - **难度**：中等，适合初学者熟悉反射访问对象属性的基本操作。

#### 3. **I/O**

- **练习：通讯录管理**

  - **描述**：编写一个 Java 程序，实现简单的通讯录功能：

    - 用户可以添加联系人信息（姓名、电话），并将其存储到本地文件中。
    - 用户可以查看所有联系人信息，从文件中读取并显示。

  - **要求**：每次运行程序时，都能保留之前存储的联系人信息。

  - **难度**：中等，掌握文件读写操作与持久化存储。

#### 4. **多线程**

- **练习1：文件查找**

  - **描述**：编写一个 Java 程序，实现以下功能：
    - 创建一个多线程程序，在指定的目录下搜索包含特定关键字的文件。
    - 每个线程负责搜索一个子目录，提高搜索效率。
    - 输出包含关键字的文件路径列表。
  - **提示**：使用多线程和文件 I/O 操作。
  - **难度**：较高，理解线程的创建、管理及同步机制。

- **练习2：生产者-消费者问题**

  - **描述**

    实现一个经典的生产者-消费者模型，使用多线程和线程间的同步机制管理共享缓冲区。此练习帮助您理解线程同步、等待/通知机制以及并发问题的解决方法。

  - **要求**

    **1. 角色定义**：

    - **生产者（Producer）**：生成数据并将其放入共享缓冲区。
    - **消费者（Consumer）**：从共享缓冲区中取出数据进行处理。

    **2. 共享缓冲区**：

    - 实现一个固定大小的缓冲区（如大小为10的队列）。
    - 使用`wait()`和`notifyAll()`方法管理生产者和消费者的同步，确保生产者在缓冲区满时等待，消费者在缓冲区空时等待。

    **3. 多线程支持**：

    - 支持多个生产者线程和多个消费者线程同时运行。
    - 确保线程安全，避免数据竞争和资源冲突。

    **4. 数据处理**：

    - 生产者生成的数据可以是简单的数值、字符串或自定义对象。
    - 消费者对取出的数据执行简单的处理，如打印、计算或存储。

    **5. 示例应用**：

    - 创建多个生产者和消费者线程，启动并观察数据在缓冲区中的流动。
    - 测试缓冲区在不同负载下的行为，如高生产率或高消费率，确保系统的稳定性。

  - **提示**

    - 使用`synchronized`关键字保护共享缓冲区的访问，确保线程安全。
    - 在缓冲区操作（添加或移除数据）时，正确使用`wait()`和`notifyAll()`方法协调线程。
    - 考虑使用`java.util.concurrent`包中的同步工具类（如`BlockingQueue`）简化实现，但建议首先手动实现以深入理解同步机制。
    - 处理线程中断和异常，确保程序的健壮性。

  - **难度**：中等，适合初学者学习多线程同步和经典并发问题的解决方法。

#### 5. **定时器**

- **练习1：定时备份程序**
  - **描述**：编写一个 Java 程序，每隔一定时间（如 10 秒）自动将指定目录下的文件复制到备份目录，实现定时备份的功能。

  - **要求**：

    - 使用定时器调度任务，支持多次备份。
    - 在控制台输出备份日志。

  - **难度**：较高，掌握定时任务的调度与管理。

- **练习2：多功能定时器应用**

  - **描述**：编写一个 Java 程序，实现以下功能：

    1. **倒计时计时器**：
       - 程序要求用户输入一个倒计时时间（以秒为单位）。
       - 启动倒计时后，每秒更新并在控制台显示剩余时间，直至倒计时结束。
       - 倒计时结束时，输出提示信息，例如“倒计时结束！”。

    2. **定时提醒任务**：
       - 程序允许用户添加多个定时提醒任务，每个任务包含以下信息：
         - **任务名称**（例如：“喝水休息”、“提交报告”）。
         - **提醒时间**（可以是具体的时间点，如“14:30”，或相对于当前的延迟时间，如“30 分钟后”）。
       - 程序在设定的时间到达时，触发提醒，在控制台输出相应的提醒信息。
       - 支持同时管理和执行多个定时提醒任务。
  - **要求**：

    1. **用户交互界面**：
       - 提供命令行菜单，供用户选择以下操作：
         - **设置倒计时计时器**
         - **添加定时提醒任务**
         - **查看当前定时任务列表**
         - **删除定时任务**
         - **退出程序**

    2. **定时器和任务管理**：
       - 使用 `java.util.Timer` 和 `java.util.TimerTask` 类，实现定时任务的调度和管理。
       - 为每个定时提醒任务创建独立的 `TimerTask`，确保任务间互不干扰。
       - 使用适当的数据结构（如 `HashMap` 或 `ArrayList`）存储和管理定时任务信息。

    3. **功能实现细节**：

       - **倒计时计时器**：
         - 支持用户输入任意正整数秒数的倒计时。
         - 每秒更新剩余时间，格式如：“倒计时剩余时间：HH:mm:ss”。

       - **定时提醒任务**：
         - 允许用户输入任务名称和提醒时间，支持多种时间格式解析。
         - 在提醒时间到达时，输出提示信息，如：“提醒：该喝水了！”。
         - 提供查看和删除已添加的任务的功能。

    4. **异常处理和输入校验**：
       - 对用户输入进行校验，防止无效输入导致程序异常。
       - 处理可能出现的异常情况，如时间解析错误、任务冲突等。

    5. **代码组织与风格**：
       - 使用面向对象的编程思想，设计合理的类和方法结构，例如：
         - `CountdownTimer` 类：处理倒计时逻辑。
         - `ReminderTask` 类：表示定时提醒任务。
         - `TaskManager` 类：管理所有的定时任务。
       - 添加必要的注释，说明代码逻辑和注意事项。
  - **扩展功能（可选）**：

    - **图形用户界面（GUI）**：
      - 使用 Swing 或 JavaFX 为应用程序添加图形界面，提升用户体验。

    - **声音提醒**：
      - 在倒计时结束或定时任务触发时，播放提示音。

    - **数据持久化**：
      - 将定时任务列表保存到本地文件中，程序重启后可继续使用。

    - **多语言支持**：
      - 提供中文和英文等多种语言的界面，方便不同用户使用。
  - **学习目标**：

    - 深入理解 Java 定时器的使用，掌握定时任务的创建和调度。
    - 练习多线程编程，处理线程间的协作和同步。
    - 提升程序的异常处理和健壮性，确保应用的稳定运行。
    - 综合运用先前学习的知识点，如集合、I/O 操作、面向对象设计等。
  - **提示**：

    - **倒计时实现**：
      - 使用 `ScheduledExecutorService` 或 `Timer` 实现每秒更新的倒计时功能。
      - 注意计算并格式化剩余时间，确保显示的时间准确。

    - **时间解析**：
      - 对于定时提醒任务，可以使用 `SimpleDateFormat` 或 `DateTimeFormatter` 解析用户输入的时间。
      - 考虑用户输入不同格式时间的情况，提供友好的提示信息。

    - **线程安全**：
      - 如果使用共享的数据结构管理任务列表，注意使用 `synchronized` 或线程安全的集合类（如 `ConcurrentHashMap`）。
  - **难度**：较高，掌握定时任务的调度与管理。

#### **6. 桌面应用**（可选）

- **练习1：简单计算器**

  - **描述**

    使用 **JavaFX** 编写一个**简单计算器**桌面应用，支持基本的数学运算功能，如加、减、乘、除。该应用应具备清晰的用户界面、响应迅速的操作以及完善的错误处理机制，适合初学者练习图形用户界面开发和基本逻辑实现。

    - **基本功能**：
      - **加法**：支持两个数的相加。
      - **减法**：支持两个数的相减。
      - **乘法**：支持两个数的相乘。
      - **除法**：支持两个数的相除，并处理除零错误。
    - **高级功能**（可选）：
      - **百分比计算**：计算百分比值。
      - **小数点支持**：支持小数的输入和运算。
      - **负数输入**：支持负数的输入和运算。
    - **用户界面**：
      - **数字按钮**：0-9的数字按钮。
      - **操作按钮**：加、减、乘、除、等于、清除等按钮。
      - **显示屏**：显示当前输入和计算结果。

  - **要求**

    **1. 图形用户界面（GUI）**：

    - 使用 **JavaFX** 构建用户友好的图形界面。
    - 设计清晰的布局，确保各功能按钮整齐排列，易于用户操作。
    - 实现响应式设计，确保界面在不同分辨率下均能良好显示。

    **2. 基本运算功能**：

    - 加法：
      - 实现两个数的相加功能。
      - 显示计算结果在显示屏上。
    - 减法：
      - 实现两个数的相减功能。
      - 显示计算结果在显示屏上。
    - 乘法：
      - 实现两个数的相乘功能。
      - 显示计算结果在显示屏上。
    - 除法：
      - 实现两个数的相除功能。
      - 处理除数为零的情况，提示用户错误信息。

    **3. 高级功能**（可选）：

    - 百分比计算：
      - 实现百分比计算功能，如计算某数的百分之几。
    - 小数点支持：
      - 允许用户输入和显示小数，支持小数运算。
    - 负数输入：
      - 允许用户输入和运算负数。

    **4. 用户界面设计**：

    - 主窗口：
      - **显示屏**：位于窗口顶部，显示当前输入和结果。
      - **按钮区域**：排列整齐的按钮区域，包括数字按钮、操作按钮和功能按钮。
    - 按钮布局：
      - **数字按钮**：按3x3网格排列，数字1-9，底部放置0。
      - **操作按钮**：位于数字按钮旁边或下方，包括加、减、乘、除、等于、清除等。

    **5. 事件处理**：

    - 为每个按钮绑定事件处理器，实现相应的功能。
    - 确保按钮点击后，显示屏能够正确更新和显示结果。

    **6. 错误处理**：

    - 处理除零错误，显示友好的错误消息，如“除数不能为零”。
    - 处理非法输入，避免程序崩溃，例如连续点击运算符按钮等。

    **7. 示例应用**：

    - 基本运算：
      - 输入数字`5`，点击`+`，输入数字`3`，点击`=`，验证显示结果为`8`。
      - 输入数字`10`，点击`-`，输入数字`4`，点击`=`，验证显示结果为`6`。
      - 输入数字`7`，点击`*`，输入数字`6`，点击`=`，验证显示结果为`42`。
      - 输入数字`20`，点击`/`，输入数字`4`，点击`=`，验证显示结果为`5`。
    - 错误处理：
      - 输入数字`8`，点击`/`，输入数字`0`，点击`=`，验证显示错误消息并重置输入。
    - 清除功能：
      - 输入一串数字和操作，点击`C`（清除）按钮，验证显示屏被清空。

  - **提示**

    - JavaFX 基础：
      - 熟悉 **JavaFX** 的基本组件，如 `Stage`, `Scene`, `Button`, `TextField`, `GridPane` 等。
      - 理解 **JavaFX** 的事件处理机制，使用 `EventHandler` 类处理按钮点击事件。
    - 界面布局：
      - 使用 **JavaFX** 的 `GridPane` 布局管理器，设计整齐的按钮网格。
      - 确保数字按钮和操作按钮排列合理，用户操作便捷。
    - 运算逻辑：
      - 使用变量存储当前输入、上一次输入和选择的运算符。
      - 实现基本的运算逻辑，处理连续运算和运算顺序。
    - 显示更新：
      - 实时更新显示屏内容，根据用户的输入和操作显示当前状态和结果。
    - 错误处理：
      - 捕获并处理除零错误或其他可能的计算错误，防止应用崩溃。
      - 显示友好的错误消息，引导用户正确操作。
    - 用户体验优化：
      - 支持键盘输入，允许用户通过键盘进行数字和操作符输入。
      - 提供简洁明了的按钮标签和布局，提升操作便捷性。
    - 测试与调试：
      - 充分测试不同运算组合，确保计算结果准确。
      - 使用调试工具跟踪问题，优化程序性能和响应速度。

  - **难度**：较高，适合初学者练习Java图形用户界面开发、事件处理和基本运算逻辑的实现。

- **练习2：联系人管理系统**

  - **描述**

    使用 **JavaFX** 编写一个**联系人管理系统**桌面应用，帮助用户存储、管理和查找个人或工作联系人信息。该应用应具备添加、编辑、删除联系人、分类管理、搜索和导出功能，并支持数据的持久化存储。

    - 核心功能：
      - 联系人管理：
        - **添加联系人**：允许用户输入联系人姓名、电话号码、电子邮件、地址、备注等信息。
        - **编辑联系人**：用户可以修改已有联系人的各项属性。
        - **删除联系人**：允许用户删除不需要的联系人。
        - **联系人分类**：支持根据不同类别（如家庭、朋友、同事、客户）组织联系人。
      - 搜索与过滤：
        - **按姓名搜索**：允许用户根据姓名快速查找联系人。
        - **按类别过滤**：提供根据联系人类别过滤的功能，便于用户查找特定类别的联系人。
      - 数据导出与导入：
        - **导出联系人**：将联系人信息导出为CSV或JSON格式文件，便于备份和共享。
        - **导入联系人**：允许用户从CSV或JSON文件导入联系人信息，支持批量添加。
      - 用户界面：
        - **菜单栏**：包含“文件”、“编辑”、“视图”等菜单，提供相应的功能选项。
        - **工具栏**（可选）：提供常用功能的快速访问按钮，如添加联系人、删除联系人、搜索框等。
        - **状态栏**（可选）：显示当前联系人总数、选中联系人信息等。

  - **要求**

    **1. 图形用户界面（GUI）**：

    - 使用 **JavaFX** 构建用户友好的图形界面。
    - 设计清晰的布局，确保各功能模块易于访问和使用。
    - 实现响应式设计，确保界面在不同分辨率下均能良好显示。

    **2. 联系人管理功能**：

    - **添加联系人**：
      - 提供输入框供用户填写联系人姓名、电话号码、电子邮件、地址、备注等信息。
      - 验证必填字段（如姓名和至少一种联系方式）的输入有效性。
      - 点击“保存”按钮后，将新联系人添加到联系人列表中。
    - **编辑联系人**：
      - 允许用户选择一个已有联系人，点击“编辑”按钮后，弹出编辑界面。
      - 修改联系人的各项属性，并保存更改，更新联系人列表。
    - **删除联系人**：
      - 允许用户选择一个或多个联系人，点击“删除”按钮，确认删除操作后从列表中移除。
    - **联系人分类**：
      - 提供下拉菜单或标签，让用户为联系人分配类别。
      - 支持按照类别查看和管理联系人，如只显示“家庭”或“同事”类别的联系人。

    **3. 搜索与过滤功能**：

    - 按姓名搜索：
      - 提供搜索框，用户输入姓名关键词后，实时过滤并显示匹配的联系人。
    - 按类别过滤：
      - 提供过滤选项，用户选择特定类别后，仅显示该类别的联系人。

    **4. 数据导出与导入**：

    - 导出联系人：
      - 允许用户将当前联系人列表导出为CSV或JSON格式的文件。
      - 使用 `FileChooser` 组件选择保存位置和文件名。
    - 导入联系人：
      - 允许用户从CSV或JSON文件导入联系人信息。
      - 解析文件内容并批量添加到联系人列表中，处理重复联系人或数据格式错误。

    **5. 数据持久化**：

    - 本地存储：
      - 选择合适的本地存储方式，如JSON文件、XML文件或SQLite数据库，保存联系人数据。
      - 实现应用启动时加载存储的数据，并在数据变动时及时保存。

    **6. 用户界面设计**：

    - **主窗口**：
      - **菜单栏**：包含“文件”（导入、导出）、“编辑”（添加、编辑、删除联系人）、“视图”（切换视图、分类过滤）、“帮助”等菜单项。
      - **工具栏**（可选）：提供快速访问按钮，如添加联系人、删除联系人、搜索框等。
      - **联系人展示区域**：以表格或列表形式展示所有联系人，显示主要信息（姓名、电话、邮箱）。
      - **状态栏**（可选）：显示当前联系人总数、选中联系人信息等。
    - **联系人对话框**：
      - **添加/编辑联系人界面**：包含输入框和选择框，供用户填写或修改联系人信息。

    **7. 示例应用**：

    - 添加联系人：
      - 启动应用，点击“添加联系人”按钮，填写联系人信息并保存，验证联系人出现在联系人列表中。
    - 编辑联系人：
      - 选择一个已有联系人，点击“编辑联系人”按钮，修改联系人属性并保存，验证修改生效。
    - 删除联系人：
      - 选择一个联系人，点击“删除联系人”按钮，确认删除，验证联系人从列表中移除。
    - 搜索与过滤：
      - 使用搜索框输入姓名关键词，验证搜索结果正确。
      - 选择特定类别进行过滤，验证列表仅显示对应类别的联系人。
    - 导出联系人：
      - 将联系人列表导出为CSV文件，打开文件验证内容正确。
    - 导入联系人：
      - 从CSV文件导入联系人，验证联系人成功添加到列表中。

  - **提示**

    - JavaFX 基础：
      - 熟悉 **JavaFX** 的基本组件，如 `Stage`, `Scene`, `MenuBar`, `TableView`, `TextField` 等。
      - 理解 **JavaFX** 的事件处理机制，使用 `EventHandler` 类处理用户交互。
    - 界面布局：
      - 使用 **JavaFX** 的 `BorderPane`、`VBox`、`HBox`、`GridPane` 等布局管理器，设计清晰且响应式的界面。
    - 数据绑定：
      - 使用 **JavaFX** 的 `ObservableList` 与 `TableView` 组件实现数据的动态更新。
      - 实现双向数据绑定，确保界面与数据模型同步。
    - 持久化存储：
      - 选择合适的序列化库（如 **Gson** 用于JSON，**JAXB** 用于XML）简化数据的读写操作。
      - 设计合理的数据库表结构（如使用SQLite），利用 **JDBC** 进行数据库操作。
    - 搜索与过滤：
      - 利用 `FilteredList` 和 `SortedList` 进行高效的搜索和过滤操作。
      - 实现实时搜索，提升用户体验。
    - 异常处理：
      - 妥善处理文件读写、数据解析、数据库操作等可能发生的异常，提供用户友好的错误提示。
      - 验证用户输入，避免非法数据导致程序崩溃。
    - 用户体验优化：
      - 提供直观的用户界面，简化操作流程，提升用户易用性。
      - 实现快捷键支持，如 `Ctrl+N`（添加联系人）、`Delete`（删除联系人）、`Ctrl+F`（搜索）等。
      - 支持多选操作，提升批量管理效率。
    - 测试与调试：
      - 充分测试不同操作组合，确保功能模块的正确性和稳定性。
      - 使用调试工具跟踪和优化应用性能，提升响应速度。

  - **难度**：高，适合具备基本Java编程和图形界面开发经验的开发者，涵盖数据管理、用户界面设计和事件驱动编程等多个知识点。

---

### **专家阶段（项目实践）**

#### 1. 项目练习：记事本应用

- **描述**

  使用 **JavaFX** 编写一个简单但功能齐全的文字编辑器，具备以下核心功能：

  - **文件操作**：
    - **新建**：创建一个新的空白文档。
    - **打开**：从本地文件系统中打开并加载现有的文本文件。
    - **保存**：将当前文档保存到本地文件系统中。
    - **另存为**：将当前文档另存为指定路径的新文件。
  - **编辑功能**：
    - **剪切、复制、粘贴**：基本的文本编辑操作。
    - **撤销与重做**：支持多级撤销与重做操作。
    - **查找与替换**：在文本中查找指定内容并进行替换。
  - **格式设置**：
    - **字体大小**：调整文本的字体大小。
    - **字体样式**：切换文本的字体样式，如粗体、斜体、下划线等。
    - **字体类型**：选择不同的字体类型（如宋体、黑体、Arial等）。
  - **用户界面**：
    - **菜单栏**：包含“文件”、“编辑”、“格式”等菜单，提供相应的功能选项。
    - **工具栏**（可选）：提供常用功能的快速访问按钮。
    - **状态栏**（可选）：显示当前文档的信息，如行数、列数、文件路径等。
  - **快捷键**：
    - 支持常用的快捷键操作，如 `Ctrl+N`（新建）、`Ctrl+O`（打开）、`Ctrl+S`（保存）、`Ctrl+C`（复制）、`Ctrl+V`（粘贴）等。

- **要求**

  **1. 图形用户界面（GUI）**：

  - 使用 **JavaFX** 构建用户友好的图形界面。
  - 设计清晰的布局，确保各功能模块易于访问和使用。
  - 实现响应式设计，确保界面在不同分辨率下均能良好显示。

  **2. 文件操作**：

  - **新建文件**：
    - 清空当前编辑区域，准备编辑新的文档。
    - 如果当前文档有未保存的更改，提示用户是否保存。
  - **打开文件**：
    - 使用 `FileChooser` 组件选择本地文本文件（如 `.txt`, `.docx`）。
    - 读取文件内容并显示在编辑区域中。
    - 处理不同文件编码和格式的兼容性。
  - **保存文件**：
    - 将当前编辑区域的内容写入指定的文件。
    - 如果文件尚未保存过，触发“另存为”功能。
  - **另存为**：
    - 使用 `FileChooser` 组件选择保存路径和文件名。
    - 将内容保存到新指定的文件中。

  **3. 编辑功能**：

  - 实现剪切、复制、粘贴功能，利用 **JavaFX** 提供的剪贴板支持。
  - 实现多级撤销与重做，使用 `UndoManager` 或自定义的撤销栈结构。
  - 实现查找与替换功能，支持全局替换和逐个替换选项。

  **4. 格式设置**：

  - **字体大小**：
    - 提供下拉菜单或滑动条供用户选择字体大小。
    - 实时更新编辑区域中选定文本或全部文本的字体大小。
  - **字体样式**：
    - 提供按钮切换粗体、斜体、下划线等样式。
    - 支持多种样式的组合应用。
  - **字体类型**：
    - 提供下拉菜单列出系统支持的字体类型。
    - 实时应用选定的字体类型到编辑区域。

  **5. 快捷键支持**：

  - 实现常用快捷键操作，提升用户体验。
  - 处理快捷键的冲突和优先级，确保功能正常触发。

  **6. 附加功能**（可选）：

  - **状态栏**：
    - 显示当前光标所在的行号和列号。
    - 显示当前文件的保存状态（已保存/未保存）。
  - **自动保存**：
    - 定时自动保存当前文档到临时文件，防止数据丢失。
  - **多语言支持**：
    - 提供多语言界面选项，提升应用的国际化程度。

  **7. 示例应用**：

  - **新建文件**：
    - 启动应用，选择“新建”命令，验证编辑区域被清空。
    - 在编辑区域输入文本，测试编辑功能。
  - **打开文件**：
    - 选择“打开”命令，选择一个现有的文本文件，验证文件内容正确加载。
  - **保存文件**：
    - 编辑文本内容，选择“保存”命令，验证内容正确写入文件。
    - 重新打开保存的文件，确保内容一致。
  - **格式设置**：
    - 修改文本的字体大小、样式和类型，验证显示效果。
    - 使用快捷键切换字体样式，验证快捷键功能。
  - **撤销与重做**：
    - 进行多次编辑操作，使用撤销与重做功能，验证操作的正确性。
  - **查找与替换**：
    - 输入包含特定关键词的文本，使用查找与替换功能进行修改，验证结果。

- **提示**

  - **JavaFX 基础**：
    - 熟悉 **JavaFX** 的基本组件，如 `Stage`, `Scene`, `MenuBar`, `TextArea` 等。
    - 理解 **JavaFX** 的事件处理机制，使用 `EventHandler` 类处理用户交互。
  - **文件操作**：
    - 使用 `FileChooser` 组件简化文件选择和保存操作。
    - 利用 `BufferedReader` 和 `BufferedWriter` 进行高效的文件读写。
  - **文本编辑**：
    - 使用 `TextArea` 或 `RichTextFX` 库实现高级文本编辑功能。
    - 管理文本样式时，考虑使用 `TextFlow` 或自定义样式应用。
  - **撤销与重做**：
    - 使用 `UndoManager` 或自定义的栈结构管理操作历史。
    - 确保线程安全，避免多线程环境下的数据竞争。
  - **快捷键实现**：
    - 利用 `Accelerator` 或 `KeyCombination` 类为菜单项绑定快捷键。
    - 处理快捷键冲突，确保快捷键功能的优先级和一致性。
  - **异常处理**：
    - 处理文件操作中的异常，如 `IOException`，并提供用户友好的错误提示。
    - 验证用户输入，避免非法操作导致程序崩溃。
  - **用户界面设计**：
    - 保持界面简洁直观，避免过于复杂的布局。
    - 使用一致的风格和颜色方案，提高用户体验。
  - **测试与调试**：
    - 充分测试各项功能，确保文件操作的准确性和稳定性。
    - 使用调试工具跟踪问题，优化程序性能。

- **难度**：高，适合熟悉 **JavaFX** 或 **Swing** 进行图形界面开发的开发者，涵盖文件操作、事件处理、文本编辑和用户界面设计等多个知识点。

#### 2. **项目练习：任务调度系统**

- **描述**：

  开发一个功能齐全的任务调度系统，支持基于时间的任务执行，类似于 Unix 的 cron。用户可以添加、修改、删除计划任务，系统按计划执行任务。

- **要求**：

  - **任务定义**：
    - 每个任务包含任务名称、执行时间（具体时间或周期）、执行的操作（如打印消息、执行脚本等）。

  - **调度功能**：
    - 支持一次性任务和周期性任务（如每天12:00执行、每隔5分钟执行）。
    - 使用 `ScheduledExecutorService` 或 `Timer` 实现任务调度。

  - **用户交互界面**：
    - 提供命令行菜单或图形界面，允许用户添加、查看、修改、删除任务。
    - 显示当前所有计划任务及其状态。

  - **任务执行**：
    - 在指定时间触发任务，执行预定义的操作。
    - 记录任务执行日志，包括执行时间、结果等。

  - **持久化存储**：
    - 将任务列表保存到本地文件或数据库中，支持程序重启后任务继续执行。

  - **错误处理**：
    - 处理任务执行失败的情况，记录错误信息。
    - 支持任务的重试机制。

- **扩展**：

  - 支持复杂的时间表达式（如“每周一、三、五的09:00”）。
  - 实现任务依赖关系，确保某些任务在其他任务完成后执行。
  - 提供任务执行结果的通知（如邮件、短信）。

- **提示**：

  - 使用 `Quartz` 库可以简化复杂的任务调度需求。
  - 确保多线程环境下的任务执行不会相互干扰。

- **难度**：高，整合多种知识点，进行系统性开发。

---

#### 3. **项目练习：贪吃蛇游戏**

- **描述**：

  使用 Java 的 JavaFX 创建经典的贪吃蛇游戏。玩家控制一条不断移动的蛇，目标是吃到食物使蛇变长，同时避免撞到墙壁或自身导致游戏结束。

- **要求**：

  1. **游戏界面**：

     - 创建一个绘制游戏区域的窗口，定义适当的大小，例如 600x600 像素。
     - 使用双缓冲或重绘机制，确保游戏界面流畅显示。

  2. **蛇的控制**：

     - 使用键盘事件监听，实现上下左右方向键控制蛇的移动方向。
     - 确保蛇不能直接反向移动（例如，当前向上移动时，不能直接向下移动）。

  3. **游戏逻辑**：

     - **蛇的移动**：蛇以恒定的速度在游戏区域内移动，每次移动一个单元格。
     - **食物生成**：在随机位置生成食物，确保食物不出现在蛇的身体上。
       - **吃食物**：当蛇的头部碰到食物时：
         - 蛇的长度增加一节。
         - 更新玩家的分数（每次加一分或自定义分值）。
         - 在新的随机位置生成新的食物。
     - **碰撞检测**：
       - **自我碰撞**：检测蛇的头部是否碰到自己的身体，如果是，游戏结束。
       - **边界碰撞**：检测蛇的头部是否碰到游戏区域的边界，如果是，游戏结束。

  4. **用户交互**：

     - **开始和重启游戏**：
       - 游戏启动后自动开始，或提供“开始游戏”按钮。
       - 当游戏结束时，显示“游戏结束”提示，提供重新开始的选项。
     - **分数显示**：在界面上实时显示玩家的当前分数。

  5. **优化与扩展（可选）**：

     - **增加难度**：随着得分增加，逐渐提高蛇的移动速度。
     - **障碍物**：在游戏区域内随机生成障碍物，增加游戏挑战性。
     - **声音效果**：添加音效，例如在吃到食物或游戏结束时播放音效。
     - **皮肤和主题**：提供不同的蛇和背景主题供玩家选择。

  6. **编程要求**：

     - **代码结构清晰**：使用面向对象的编程思想，合理拆分类，例如 `Snake` 类、`Food` 类、`GamePanel` 类等。
     - **注释完善**：为关键代码和方法编写必要的注释，方便阅读和维护。
     - **异常处理**：考虑可能的异常情况，添加必要的异常处理代码，确保程序稳定运行。

- **提示**：

  - **定时器**：使用 `javax.swing.Timer` 或 `java.util.Timer` 实现游戏的刷新和蛇的移动控制。
  - **绘图**：重写面板的 `paintComponent(Graphics g)` 方法，进行游戏元素的绘制。
  - **事件监听**：实现 `KeyListener` 接口或使用 `Key Bindings` 机制，处理键盘输入。

- **学习目标**：

  - 巩固对 Swing 图形界面的开发经验。
  - 理解游戏开发的基本逻辑和结构。
  - 练习事件驱动编程和实时刷新界面的技巧。
  - 综合运用之前学习的知识点，包括面向对象、集合、线程、定时器等（在本练习中，尽量只使用到已学过的知识点）。

- **难度**：高，涉及图形界面、事件驱动、游戏逻辑和多线程的综合应用。